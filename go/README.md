# Golang常见问题

## 编译原理

[Golang编译原理](./compile.md)

## 数据结构

[Golang数据结构](./struct.md)

## 并发模型

[Golang并发模型](./concurrent.md)

## 内存管理

[Golang内存管理](./memory.md)

## Go中对nil的Slice和空的Slice的处理是一致的吗？

nil slice和empty slice是不一致的

## context

上下文是Go语言中用来设置截止日期、同步信号，传递请求相关值的接口类型；上下文与Goroutine有比较密切的关系；

```golang
type Context interface {
 Deadline() (deadline time.Time, ok bool)
 Done() <-chan struct{}
 Err() error
 Value(key interface{}) interface{}
}
```

主要作用是在多个Goroutine组成的树中同步取消信号以减少对资源的消耗和占用；还有传值的功能，但是这个功能我们还是很少用到。

## append时的过程

针对切片类型持续进行append可能会导致切片进行扩容

校验是否赋值原有变量

### 如果不赋值原有变量  

1、首先获取当前切片的数组指针、大小、容量  
2、如果追加的元素后，长度大于容量，会触发切片的扩容  
3、最后将追加的元素添加到指定的数组中

### 如果赋值原有变量  

Go语言编译器已经对这种常见的情况做出了优化  
其他步骤与不赋值原有变量逻辑一致  

## append引发的扩容

1、如果期望容量大于当前容量的两倍就会使用期望容量；  
2、如果当前切片的长度小于 1024 就会将容量翻倍；  
3、如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；  

以上仅是针对容量大小的简单计算，还会设计内存对齐

需要注意的是在遇到大切片扩容或者复制时可能会发生大规模的内存拷贝，一定要减少类似操作避免影响程序的性能。

## 一个二维数组，行遍历快还是列遍历快，为什么？

1、CPU高速缓存：在计算机系统中，CPU高速缓存是用于减少处理器访问内存所需平均时间的部件。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近处理器的频率。当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。缓存之所以有效，主要是因为程序运行时对内存的访问呈现局部性（Locality）特征。这种局部性既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality）。有效利用这种局部性，缓存可以达到极高的命中率。  
 2、缓存从内存中抓取一般都是整个数据块，所以它的物理内存是连续的，几乎都是同行不同列的，而如果内循环以列的方式进行遍历的话，将会使整个缓存块无法被利用，而不得不从内存中读取数据，而从内存读取速度是远远小于从缓存中读取数据的。随着数组元素越来越多，按列读取速度也会越来越慢。

## 并发读写map会发生什么？怎么避免?

fatal error: concurrent map read and map write  
会发生并发读写问题

1、在1.9之前可以定义一个结构体加上一把读写锁来解决并发安全问题；
2、1.9之后官方在sync包定义了Map结构体，如果遇到并发问题，可以使用sync.Map解决。  

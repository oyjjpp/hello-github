# redis 常见问题

## redis 学习路线

![image](./redis.jpg)

## redis问题画像

![image](./redis_question.jpeg)

## redis为什么那么快？

>完全基于内存的操作，可以减少读取磁盘的消耗  
>单进程的，可以避免多线程切换问题和并发控制问题  
>非阻塞IO：redis采用epoll作为IO多路复用的事件模型，可以减少IO上的损耗  
>Redis采用一些常见的高效索引结构作为某些value类型的底层数据结构，这一技术路线为Redis实现高性能访问提供了良好的支撑。

## redis有时访问慢的原因

>哈希冲突  
>正在进行rehash  

## redis的数据类型有哪几种，使用了那种？是怎么使用的？

string/hash/list/set/zset

## string类型的底层数据结构是怎么样的？

 [redis_struct](./Struct.md)

## 删除数据内存占用还是很高?

>内存分配策略局限性，一般都会分配固定的空间大小，导致实际分配的内存空间大于实际申请的，从而多出了许多不连续的空闲内存块。  
>键值对的修改、删除导致了内存的扩容或者释放，导致多余的不连续的空闲内存块。  

### 解决方案

**方案一**
重启redis（需要考虑是否进行了数据持久化）

**方案二**
要求redis>4.0  
设置自动清理  
config set activedefrag yes  

### 参考

[为什么删除数据后，Redis内存占用依然很高？](https://www.oschina.net/group/database#/detail/2371060)

## redis的分布式锁用过吗？，怎么用的？

[分布式锁](.DistributedLock.md)

## redis是怎么实现原子性的?

对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。  
执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程去负责执行，任务要么执行成功，要么执行失败，这就是Redis的命令是原子性的原因。  
Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。

## redis为什么要用单线程？

1、实现简单，不用考虑处理资源的竞争  
2、减少多线程上下文切换的消耗  

因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽；既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。

### redis 单线程的优劣势

#### 优势

1、代码清晰，处理逻辑更简单  
2、不用考虑因为多线程导致得各种锁得问题  
3、不存在多进程或者多线程导致的切换而消耗CPU

#### 劣势

无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；

[Redis为什么是单线程，高并发快的3大原因详解](https://zhuanlan.zhihu.com/p/58038188)

## Redis单线程处理IO请求性能瓶颈主有哪些?

1、任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成；  
2、并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。

## redis6.0 为什么引入多线程？

1、可以充分利用服务器CPU资源，目前主线程只能利用一个核  
2、多线程任务可以分摊Redis同步IO读写负荷

## 最新的redis6.0用了多线程，是怎么实现的？

redis的多线程主要是针对IO写度进行了多线程，来提供redisIO的性能  
[Redis 6.0 新特性-多线程连环13问！](https://www.cnblogs.com/madashu/p/12832766.html)

## Redis6.0与Memcached多线程模型对比

相同点：都采用了master线程worker线程的模型  
不同点：Memcached执行主逻辑也是在worker线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解；而Redis把处理逻辑交还给master线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。

## redis与memcached的区别

|redis|memcached|
|-----|-----|
| 支持多种数据类型| 只支持string类型|
| redis6.0之前是单进程的| 是多进程的|
| 支持持久化| 不支持|
|支持数据备份| 不支持|

## 整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么Redis还会把它们作为底层数据结构呢？

1、内存利用率，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。

2、数组对CPU高速缓存支持更友好，所以Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。

## 事件模型

## reids基本IO模型

![image](./redis_io.jpg)

## 备份

[AOF和RDB](./backups.md)

## 集群

[主从库](./master_slave.md)

## redis 特点

1、支持丰富的数据类型（string/list/hash/set/zset）  
2、支持持久化(aof/rdb)  
3、支持主从模式和哨兵机制的高可用  
4、内存过载时的淘汰算法  
5、支持集群和分片的横向扩展  

[redis中文社区文档](http://www.redis.cn/documentation.html)
